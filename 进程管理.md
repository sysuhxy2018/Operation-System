# 进程管理

### 进程&线程

* 进程是资源分配的基本单位。
* 进程的基本信息和运行状态通过进程控制块（PCB）显示。
* 进程可以并发执行，注意不是并行。比如你可以一边听歌，一边打LOL。



* 线程是独立调度的基本单位。
* 一个进程中可以有多个线程，它们共享进程资源。
* 线程也可以并发执行。比如浏览器在执行HTTP请求线程的同时还可以响应用户的其他事件，不会卡死。

两者的区别：

* 线程不占有资源，只能访问所属进程的资源。
* 同进程中线程的切换不会引发进程切换；从进程A的线程切换到进程B的线程时，需要进程切换。
* 进程的开销相比线程要大很多。进程创建时要分配资源，撤销时要回收资源，切换时要进行上下文交换。
* 线程间通信更简单，因为它们都共享同一资源；进程间通信需要借助IPC。



### 进程状态

一般有3种基本状态。

* 就绪(ready)。
  * 进程已分配到了除CPU外的所有必要资源，等待被CPU调度（获取时间片）。
  * 进程在CPU调度（分配时间片）后就进入执行状态。
* 执行(running)。
  * 进程已获得CPU并正在执行。
  * 如果时间片用完，则进程从执行态回到就绪态。
  * 如果因为进程请求I/O，请求的资源被其他进程占用等事件使得执行受阻，则进入阻塞状态。
* 阻塞(blocked)。
  * 只在执行的进程由于某些事件需要放弃CPU，从而进入等待状态。
  * 如果I/O完成或者请求的资源被释放（可被访问）时重新从阻塞态进入就绪态。

![Process State](https://img2018.cnblogs.com/blog/1330620/201809/1330620-20180915131910362-1573414576.png)



### 进程调度算法

首先搞清楚几个时间变量，在计算题中很常用。

* 到达时间
* 服务时间

根据这两个变量可以推导出：

* 开始时间
* 完成时间 = 开始时间 + 服务时间
* 等待时间 = 开始时间 - 到达时间
* 周转时间 = 完成时间 - 到达时间
* 带权周转时间 = 周转时间 / 服务时间

另外，还有两个重要概念：

* 非抢占式
  * 当一个进程在执行时，如果有新的进程到达（进入就绪队列），不管其优先级的高低，都要等**当前进程执行完**或者进入阻塞态时，再从就绪队列中选择新的优先级最高进程执行（分配CPU时间片）。
* 抢占式
  * 有新的进程到达，且优先级更高，则将当前进程放回就绪队列，执行新的进程（优先级最高）。
  * 另一种情况是当前进程时间片用完回到了就绪态，只能执行其他进程。

简单区分就是看进程是否一口气执行完还是分多次执行。

常用调度算法有：

* 先来先服务(FCFS)。
  * 是一种非抢占式调度算法，优先级是到达时间。
  * 特点是有利于长作业，但不利于短作业。短作业的等待时间太长（等待长作业完成）。
* 短作业优先(SJF)。
  * 非抢占式，优先级是服务时间。
  * 特点是有利于短作业，但不利于长作业。长作业可能一直处于等待状态，会被饿死。
* 抢占式短作业优先(SPF)。
  * 也称为最短剩余时间优先(SRTN)，优先级是剩余服务时间。
  * 如果新进程所需服务时间少于当前进程的剩余服务时间，则运行新进程，当前进程等待。如果存在多个进程剩余时间相等，按FCFS处理。
  * 特点类似于SJF，存在饥饿问题。
* 时间片轮转(RR)。
  * 抢占式。
  * 按FCFS排成就绪队列，每次CPU调度队首的进程，并分配时间片给该进程。时间片用完就会停止执行当前进程并将其放到就绪**队列末尾**，然后继续分配时间片给新的队首进程。如果进程提前执行完毕，则会撤销该进程并执行新的队首进程。
  * 时间片太长或太短都不好，要合理设置。
  * RR不存在饥饿问题，所有进程都公平对待。
* 多级反馈队列(MFQ)。
  * 设置了多层不同优先级的就绪队列。第一层优先级最高，时间片最短；后面的层数优先级递减，时间片（指数）递增。时间片长度一般为1,2,4,8......这样。
  * 新到的进程都会先放到第一层就绪队列的末尾（按照FCFS排队）。第一层的进程如果在时间片内完成，则直接撤销；否则放到第二次队列的末尾（同样按FCFS）......以此类推。
  * 只有当第 1, 2, ......, i - 1层的队列**都为空**时，才从第 i 层队列调度进程。
  * MFQ是抢占式的，体现在如果正在执行一个低优先级队列的进程，这时新来了一个进程（必然会放到第一层），那么当前进程会被放回到该层就绪队列的末尾。然后从高优先级队列开始调度。
    * 注意如果不能完整执行完一个时间片（被抢占），则放到该层末尾；而如果能够完整执行完，则放到下一层末尾。
  * MFQ是一种比较合理的调度算法。下图演示了MFQ的过程，数字表示第 i 层队列。
    * <img src="https://img-blog.csdnimg.cn/20181110120734681.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poMTM0ODc=,size_16,color_FFFFFF,t_70" style="zoom:75%;" />





