# 页面置换算法

页面置换算法的目的是使页面置换频率（缺页率）最低。通常有下面6种方法：

* 最佳（OPT）
  * 是一种理论算法，可以获得最低的缺页率。
  * 替换的页面是统计上最长时间不被访问的页面，由于必须开上帝视角获得过去到未来的数据，所以只存在于理论上。
* 最近最久未使用（LRU）
  * 考虑过去使用页面的情况。实际上替换掉的是当前所有缓存页（数量到达max）中**上一次使用距离现在最远**的那个。形容起来比较拗口，但实现起来并不难。
  * 可以通过一个链表来组织所有页，当使用一个页（插入/再命中）时，将它放到链表表头（或者末尾）；当需要替换一个页时，选择链表末尾（或者头部）的页删除。然后将新页放到表头（或者末尾）。具体可以参考Leetcode [146](https://github.com/sysuhxy2018/leetcode/blob/master/%E9%93%BE%E8%A1%A8/lc146.md)。
* 最近未使用（NRU）
  * 每个页面维护两个1bit的状态位，R和M。页面被访问时（插入/再命中），R设为1；被修改（修改前肯定要先访问）时，M设为1。另外，R每隔一段时间会被清零。
  * 排列组合一共可以得到4种不同的RM。需要替换时，**随机**从除R = 0 && M = 0外的3中情况中选择编号和最小的。
    * 对于R = 0 && M = 1和R = 1 && M = 0的情况，优先替换掉前者。即优先考虑R小的，然后考虑M小的。
* 先进先出（FIFO）
  * 比较简单粗暴，通过一个队列就可以实现。将所有页按照访问的先后次序排列，替换时删除最早出现的（队首），然后将新的页插入队尾。
    * 如果某一页已经在队列里了，访问的时候不会动它，即不会把它提到队列的末尾按照一个最新的页对待。
* 第二次机会算法
  * FIFO的缺点在于容易把经常使用的页面替换掉。
  * 第二次机会对此做了简单的改进：
    * 即每一页维护一个1bit的标记位R。如果被访问时，R设置为1。
    * 如果队首页替换时，检查它的R，如果R = 0，直接删除掉；如果R = 1，将R重置为0，然后把它提到队尾按照一个最新页处理，接着继续从新的队列找队首页检查。（相当于给了“第二次机会”）
* 时钟
  * 无论是使用队列还是链表，第二次机会算法都需要移动结点，效率比较低。
  * 时钟对此做了简单的改进，基本只需要**移动指针**即可：
    * 将所有页首尾相连，用一个**环形链表**串联起来。
    * 然后用一个指针指向最老的页面（也就是队首），如果它的R = 0，则直接修改该页面为新页面（不需要先删除再插入），然后指针移至下一个页面（如果是按顺时针排列的，则顺时针移动；逆时针同理）；如果R = 1，则R清零，指针移至下一个页面，继续寻找可替换的页面。

